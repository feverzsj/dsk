#pragma once

#include <string_view>


namespace dsk{


template<class T>
consteval std::string_view get_raw_type_name() noexcept
{
#ifdef _MSC_VER
    return __FUNCSIG__;
#else
    return __PRETTY_FUNCTION__;
#endif
}

inline constexpr auto raw_type_name_prefix_suffix =
[](){
    auto probe = get_raw_type_name<int>();
    auto prefix = probe.find("int");

    if(prefix == std::string_view::npos || prefix != probe.rfind("int"))
        throw "unsupported format";

    auto suffix = probe.size() - prefix - (sizeof("int") - 1);

    return std::pair(prefix, suffix);
}();

template<class T>
consteval std::string_view get_type_name()
{
    auto name = get_raw_type_name<T>();

    name.remove_prefix(raw_type_name_prefix_suffix.first);
    name.remove_suffix(raw_type_name_prefix_suffix.second);

#ifdef _MSC_VER
    if(name.starts_with("class "))
        name.remove_prefix(sizeof("class ") - 1);
    else if(name.starts_with("struct "))
        name.remove_prefix(sizeof("struct ") - 1);
    else if(name.starts_with("union "))
        name.remove_prefix(sizeof("union ") - 1);
#endif

    return name;
}


// NOTE: the name may change across compilers + versions.
//       so they should not be used for things like serialize/deserialize
//       with binaries generated by different toolset.
template<class T>
inline constexpr auto type_name = get_type_name<T>();


} // namespace dsk
